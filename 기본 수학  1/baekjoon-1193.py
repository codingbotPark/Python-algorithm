# 오른쪽 대각선으로 무한히 큰 배열을 자른다면
# 배열은 1,2,3,4... 의 길이가 될 것, 즉 1씩 증가하는 형태의 무한히 많은 1차원 배열이  만들어질 것이다
# 요기서 x에 1,2,3,4 씩 빼서 x를 0이 되지 않는 최소한의 수로 만든 후
# 1,2,3.. 이렇게 뺀 횟수와 x번째를 계산한다

# 자세한 계산 법을 예시로 알아보면
# x가 12(4/2)이라면 1,2,3 씩 뺀 회수(x가 영이 되지 않는)가 4가되고 x는 2가된다
# 그러면 1/5가 인덱스0 인 배열 안에 x가 있다고 생각할 수 있고
# 1/5 = n/m 이라 생각해서 n+=1 m-=1을 하며 x번째(2) 한 값을 찾는다
# 요기서 원래 지그재그로 수를 세고 지그재그할 때 1/1 에서 1/2 부터 세었기 때문에 1/3, 즉 홀수번째 배열에서 배열을 거꾸로 해서 return 해야 되는 것을 알 수 있다 
# 즉 요기서는 1/5 에서 2/4 가 되고 홀수번째 배열에 x가 위치했기 때문에 거꾸로 해서 리턴을 하면 4/2 가 리턴 된다는 것을 알 수 있다

x = int(input())

miNum = 1 # 빼는 수
while 1:
    if (x - miNum <= 0): 
        # x에 빼는 수를 뺏을 때 0 이하가 되면 안된다
        break
    else:
        x -= miNum
        miNum += 1 # 빼는 수 증가
n = x
m = (miNum) - (x - 1)
if miNum % 2 == 0: #짝수일 땐 그냥 출력
    print(f"{n}/{m}")
else:
    print(f"{m}/{n}")


# 출처 : https://jinisbonusbook.tistory.com/48
# 여러개의 변수들을 리턴하는 함수에서 리턴값은
# 콤마 구분자로 각각을 받아도 되고, 튜플 형식으로 받아도 된다

# 시행착오
# 수가 일정한 패턴을 가지고 있어서 인덱스에 따른 수 변화로 문제를 풀 수도 있지만 현제 나의 능력으로는 할 수 없었다
#
# 큰 배열의 가로세로 끝 인덱스의 값 변화를 본다
#
# 가로를 먼저 보자면
# 1(1/1) -> 2(1/2) -> 6(1/3) -> 7(1/4) -> 15(1/5) -> 16(1/6) -> 28(1/7)
# 즉 +1 -> 4증가 -> +1 -> 8증가 -> +1 -> 12증가
# 즉 4씩 증가하여 증가하는 것을 확인할 수 있다
#
# 세로를 보자면
# 1(1/1) -> 3(2/1) -> 4(3/1) -> 10(4/1) -> 11(5/1) -> 21(6/1)
# 즉 2증가 -> +1 -> 6증가 -> +1 -> 10증가
# 즉 4씩 증가하여 증가하는 것을 확인할 수 있다
#
# 1 -> 5 -> 13 -> 25
# 4,8,12 증가
# 1곱하기 1,2,3,4


# https://deokkk9.tistory.com/11 코드
# 나와 같은 방식으로 풀었다
# 1시간 반정도 고민해서 푼 문제인데 나만 이렇게 푼게 아니였다
X=int(input())

line=1
while X>line:
    X-=line
    line+=1
    
if line%2==0:
    a=X
    b=line-X+1
else:
    a=line-X+1
    b=X
    
print(a, '/', b, sep='')